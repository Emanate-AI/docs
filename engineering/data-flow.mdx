---
title: "Data Flow"
description: "Understanding the 'VAPI Writes, Supabase Reads' pattern"
---

# Data Flow Patterns

Emanate uses a specific data flow pattern to ensure consistency and performance: **VAPI Writes, Supabase Reads**.

## The Pattern

```
┌─────────────────────────────────────────────────────────────────┐
│                        VAPI                                      │
│                  (Source of Truth)                               │
│                                                                  │
│  All CREATE, UPDATE, DELETE operations go here first            │
└─────────────────────────────────────────────────────────────────┘
                           │
                           │ Sync after every write
                           ▼
┌─────────────────────────────────────────────────────────────────┐
│                      Supabase                                    │
│                    (Read Cache)                                  │
│                                                                  │
│  All LIST, GET operations read from here                        │
└─────────────────────────────────────────────────────────────────┘
```

## Why This Pattern?

### Problem: VAPI API Latency

VAPI's list APIs can be slow:
- No filtering by org
- Returns all resources
- 200-500ms per request

### Solution: Supabase Cache

After every VAPI write:
1. Sync the data to Supabase
2. Read from Supabase (instant)
3. Use Supabase for filtering

## Write Flow

### Creating an Assistant

```typescript
async createAssistant(data: CreateAssistantRequest, orgId: string) {
  // 1. Create in VAPI (source of truth)
  const assistant = await this.vapi.createAssistant(data);
  
  // 2. Sync to Supabase
  await this.syncToSupabase(assistant, orgId);
  
  return { success: true, data: assistant };
}
```

### Updating an Assistant

```typescript
async updateAssistant(id: string, updates: UpdateAssistantRequest) {
  // 1. Get current state from VAPI
  const current = await this.vapi.getAssistant(id);
  
  // 2. Deep merge to preserve fields
  const merged = applyDeepMerge(current, updates);
  
  // 3. Update in VAPI
  const updated = await this.vapi.updateAssistant(id, merged);
  
  // 4. Sync to Supabase
  await this.syncToSupabase(updated, orgId);
  
  return { success: true, data: updated };
}
```

### Deleting an Assistant

```typescript
async deleteAssistant(id: string) {
  // 1. Prefetch related data
  const { toolIds, outputIds } = await this.prefetchData(id);
  
  // 2. Cleanup related resources in VAPI
  await this.cleanupTools(toolIds);
  await this.cleanupOutputs(outputIds);
  
  // 3. Delete from VAPI
  await this.vapi.deleteAssistant(id);
  
  // 4. Delete from Supabase
  await this.deleteFromSupabase(id);
  
  return { success: true };
}
```

## Read Flow

### Listing Assistants

```typescript
async listAssistants(orgId: string, type: "voice" | "chat") {
  // Read directly from Supabase - no VAPI call!
  const { data } = await supabase
    .from("assistants")
    .select("*")
    .eq("org_id", orgId)
    .eq("agent_type", type)
    .order("created_at", { ascending: false });
  
  return { success: true, data };
}
```

### Getting Single Assistant

```typescript
async getAssistant(id: string) {
  // Read from Supabase first (fast)
  const { data } = await supabase
    .from("assistants")
    .select("*")
    .eq("vapi_assistant_id", id)
    .single();
  
  if (data) {
    return { success: true, data: data.vapi_data };
  }
  
  // Fallback to VAPI if not in cache
  const assistant = await this.vapi.getAssistant(id);
  return { success: true, data: assistant };
}
```

## Supabase Schema

### Assistants Table

```sql
CREATE TABLE assistants (
  id UUID PRIMARY KEY,
  vapi_assistant_id TEXT UNIQUE NOT NULL,
  org_id TEXT NOT NULL,
  agent_type TEXT NOT NULL,
  vapi_data JSONB NOT NULL,
  
  -- Denormalized for filtering/search
  name TEXT,
  first_message TEXT,
  avatar_url TEXT,
  
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Indexes for fast queries
CREATE INDEX idx_assistants_org ON assistants(org_id);
CREATE INDEX idx_assistants_type ON assistants(agent_type);
```

### Sync Function

```typescript
async syncToSupabase(assistant: Assistant, orgId: string) {
  await supabase.from("assistants").upsert({
    vapi_assistant_id: assistant.id,
    org_id: orgId,
    agent_type: assistant.metadata?.agentType || "voice",
    vapi_data: assistant,
    name: assistant.name,
    first_message: assistant.firstMessage,
    updated_at: new Date()
  }, {
    onConflict: "vapi_assistant_id"
  });
}
```

## Deep Merge for Updates

VAPI's PATCH replaces nested objects entirely. We must merge locally:

### The Problem

```typescript
// Current assistant
{ model: { toolIds: ["tool_1"], temperature: 0.7 } }

// Update sent
{ model: { temperature: 0.5 } }

// VAPI result (toolIds lost!)
{ model: { temperature: 0.5 } }
```

### The Solution

```typescript
function applyDeepMerge(current: Assistant, updates: Partial<Assistant>) {
  return {
    ...current,
    ...updates,
    model: {
      ...current.model,
      ...updates.model,
    },
    voice: {
      ...current.voice,
      ...updates.voice,
    }
  };
}
```

## Handling Failures

### Rollback on Sync Failure

```typescript
async createAssistant(data, orgId) {
  let assistant = null;
  
  try {
    // 1. Create in VAPI
    assistant = await this.vapi.createAssistant(data);
    
    // 2. Sync to Supabase
    await this.syncToSupabase(assistant, orgId);
    
    return { success: true, data: assistant };
  } catch (error) {
    // Rollback: delete from VAPI if sync failed
    if (assistant) {
      await this.vapi.deleteAssistant(assistant.id);
    }
    throw error;
  }
}
```

## Cache Invalidation

### Next.js Revalidation

```typescript
// After successful write
revalidatePath("/voice-agents");
revalidatePath("/chat-agents");
revalidatePath(`/agents/${id}`);
```

### Manual Refresh

```typescript
// In React component
const { refresh } = useAssistants();

const handleUpdate = async () => {
  await updateAssistant(id, updates);
  refresh(); // Refetch from Supabase
};
```

## Performance Benefits

| Operation | Before (VAPI Direct) | After (Supabase Cache) |
|-----------|---------------------|------------------------|
| List 50 assistants | 300-500ms | 20-50ms |
| Filter by type | 300ms + client filter | 30ms (DB filter) |
| Search by name | Not supported | 40ms |

## Next Steps

<CardGroup cols={2}>
  <Card title="VAPI Integration" icon="phone" href="/engineering/vapi-integration">
    4-layer architecture
  </Card>
  <Card title="Architecture" icon="sitemap" href="/engineering/architecture">
    System overview
  </Card>
</CardGroup>
